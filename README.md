Deployer - консольная утилитка для накатов изменений в Oracle Database изменений из гита.

Для корректной работы требуется клиент oracle с sqlplus и git. На Windows git должен быть установлен вместе с bash (должно быть доступно `Git Bash Here` в контекстном меню).

### Ограничения:

* Утилита не слишком удобна, если у вас много баз в одном репозитории - нужно будет заводить несколько переменных с путем и менять подключения.
* Или если несколько репозиториев на одно БД - предполагается, что деплоер лежит в корне вашего репозитория 
* Предполагается, что организация хранения кода в репозитории /<PATH>/<SCHEMA>/<OBJECT_TYPE>/<OBJECT_NAME>.sql. <PATH> может быть DB_NAME или любой путь
* Утилита не управляет сложными сценариями деплоя. Весь порядок наката управляется вами.

### Возможности:

* Генерировать скрипт наката по изменениям в репозитории
* Накатывать ваши изменения из гита (или любой код указанный в файле `task_to_deploy.sql`) с последующей компиляцией развалившихся объектов
* Получить исходный код с вашей БД нужных объектов
* Получить весь исходный код с вашей БД, если почему-то у вас еще не используется гит или актуализировать его
* Скомпилировать инвалидные объекты
* Пересобрать индексы в статусе unusable (это лучше делать руками, но для ленивых и так сойдет)

### При первом использовании:

* Закинуть deployer в каталог с исходным кодом вашей DB
* Из каталога templates скопировать все файлы в каталог `deployer/`. Это основные файлы, их придется часто менять. Их изменения не должны отслеживаются гитом
* Указать параметры подключения в файле `config.sql`. У учетной записи должны быть права на запросы к представлениям dba_* и всем схемам, в которые вам нужно вносить изменения. Если коннект к tns не удается - укажите путь к tnsnames.ora в переменной окружения TNS_ADMIN
* При необходимости указать схемы в скриптах

### Запуск

Перейти в папку деплоера. В винде в контекстном меню тыкнуть `Git bash here`
```
cd <PATH_TO_GIT_PROJECT>/deployer/
```

Запустить с нужным флагом:
```
sh.deploy.sh <flag>

# Для вывода справки:
sh deploy.sh -h
# или
sh deploy.sh --help
```

Опционально:

Для более быстрого запуска в ~/.bashrc добавить:
```
export DEPLOYER_PATH=<PATH_TO_GIT_PROJECT>/deployer/
alias deploy="sh ${DEPLOYER_PATH}/deploy.sh"
```
Сразу после перезапустить оболочку или выполнить `source ~/.bashrc`
После этого больше не нужно оболочке находится в каталоге с деплоером и можно запускать скрипт из любого каталога

### Для получения кода с базы

В файле `backup.sql` добавить вызовы для объектов, код которых нужно выгрузить с БД:

```
@src/get_source.sql 'object_owner' 'object_name' 'package'
@src/get_source.sql 'object_owner' 'object_name' 'package body'
```

```
sh deploy.sh -b
```

Результат будет в папке backup/OWNER.NAME.DATETIME..sql

Этими файлами можно воспользоваться чтобы откатить неудачный накат или проверить актуальность кода в репозитории.
При добалении `define spool_to_git="true"` код заспулится прямо в локальный репозиторий, а не в отдельную папку.

### Для наката:

В файле `task_to_deploy.sql` указать пути к файлам для накатки в нужном порядке и/или ddl/dml операторы

```
alter session set current_schema = owner;
alter table ...;
@../DB_PATH/OWNER/TYPE/OBJECT_NAME.sql
```

```
sh deploy.sh -d
```

После накатки будет выполнена компиляция инвалидов

После запуска рекомендуется убрать выполненные инструкции в файлах `backup.sql` и `task_to_deploy.sql`, чтобы избежать повторного выполнения

### Сгенерировать скрипт наката

Для генерации берется список измененных файлов по всем коммитам (в том числе не закомиченные изменения) в текущей ветке, т.е. в списке будет все изменения по сравнению с веткой master.
Для ветки master берется список измененных файлов (т.е. то что еще не коммитили), а если таких файлов нет, то список формируется из файлов в самом последнем коммите.
Порядок скриптов всегда нужно проверять
```
# Для вывода команд в консоль:
sh deploy.sh --script-show

# Для записи этих команд в task_to_deploy.sql
# Все комманды будут закомичены, чтобы случайно не задеплоить.
sh deploy.sh --script-prepare
```
После - отредактировать скрипт `task_to_deploy.sql` - поправить порядок, добавить ddl если нужно, убрать комменты и после деплоить


### Получить инвалиды с базы без компиляции и список unusable индексов

```
sh deploy.sh -i
```

### Скомпилировать инвалиды

```
sh deploy.sh -c
```

### Перестроить индексы в статусе unusable

```
sh deploy.sh --rebuild-unusable
```

### Акутализация гита

1. При частичной актуализации:
В файле `global_vars.sql` отредактировать переменные `git_last_ddl_*` при необходимости.
В файле `config.sql` отредактировать переменные `git_susp_grants`, `git_owner`, `git_type`, `ignore_last_ddl` при необходимости.
1. Сгенерировать скрипт актуализации командой
```
sh deployer.sh --git-update-prepare
```
1. Проверить сгенерированный файл `make_git_great_again.sql`. Можно удалить лишние вызовы
1. Для запуска актуализации:
```
sh deployer.sh --git-update-run
```
1. Проверить результат в git, при необходимости подправить/откатить локальные изменения
1. Если не указывались фильтры `git_susp_grants`, `git_owner`, `git_type` - поставить текущую дату в `git_last_ddl_main`
1. git add . && git commit && git push

#### Ускоренная актуализация:
```
sh deployer.sh --git-update
```
Выполнение команды аналогично команде:
```
sh deployer.sh --git-update-prepare && sh deployer.sh --git-update-run
```
Но! Внести правки в файл `make_git_great_again.sql` при таком вызове не получится

Из актуализации исключены:
* wrapped объекты
* тестовые объекты по маскам *TEST*, TMP_*, *_TMP, *_TST
* MV logs, JOBS, table ddl
