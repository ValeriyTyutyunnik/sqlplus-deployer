#!/bin/bash

COLOR_BLACK="\033[30m"
COLOR_RED="\033[31m"
COLOR_GREEN="\033[32m"
COLOR_YELLOW="\033[33m"
COLOR_BLUE="\033[34m"
COLOR_VIOLET="\033[35m"
COLOR_CIAN="\033[36m"
COLOR_GRAY="\033[37m"

FILE_CONFIG=config.sql
FILE_GLOBAL_VARS=global_vars.sql
FILE_TASK=task_to_deploy.sql
FILE_BACKUP=backup.sql
FILE_GIT_UPDATE=make_git_great_again.sql
FILE_MAIN=main.sql
DIR_BACKUP=backup/
DIR_LOG=logs/

BASEDIR=$(dirname $(realpath "$0"))
cd $BASEDIR

CUR_BRANCH=$(git branch --show-current)
[[ 0 -ne $? ]] && exit 1
MAIN_BRANCH=$(git symbolic-ref refs/remotes/origin/HEAD --short | sed 's@^origin/@@') # main or master

deploy_mode=""

function PrintHelp() {
  echo "Usage: deployer <flag>"
  echo
  echo "<flag> is:"
  echo "  -h | --help             Print this help and exit"
  echo "  -d                      Deploy script $FILE_TASK and compile all invalid objects. Specify scenario in $FILE_TASK first"
  echo "  -c                      Compile all invalid objects"
  echo "  -i                      Show invalid objects and unusable indexes"
  echo "  -b                      Save DB source code to $DIR_BACKUP dir. Specify objects in $FILE_BACKUP first"
  echo "  --rebuild-unusable      Rebuild unusable indexes"
  echo "  --script-prepare        Add changed files paths from current branch to $FILE_TASK as deploy commands. Change commands ordering correctly if need"
  echo "                          If current branch is '$MAIN_BRANCH' and there are no local or staged changes then works with files from very last commit"
  echo "  --script-show           Same as --script-prepare, but only print output without changing $FILE_TASK"
  echo "  --git-update-prepare    Generate script $FILE_GIT_UPDATE to update git sources. Used by --git-update-run"
  echo "  --git-update-run        Update git sources by script generated by --git-update-prepare"
  echo "  --git-update            --git-update-prepare && --git-update-run at once"
  echo "  --clear-logs            Remove spam from directory $DIR_LOG"
  echo "  --clear-backup          Remove spam from directory $DIR_BACKUP"
  echo "" # This should be last
}

function CheckFile() {
  if [[ ! -f $1 ]] ; then
    echo -e "${COLOR_RED}Missing file: ${COLOR_CIAN}$1"
    exit 1
  fi
}

function ScriptPrepare() {
  local comment="" last_schema="" cur_schema="" text="" deploy_files=""

  if [[ "$1" != "show" ]]; then
    CheckFile $FILE_TASK
    comment="-- "
    text="\n\n-- Generated by deployer script. Uncomment lines after correction\n"
  fi

  if [[ $CUR_BRANCH == $MAIN_BRANCH ]]; then
    deploy_files=$( (git diff --name-only && git diff --name-only --staged) | uniq -u )
    if [[ ${#deploy_files} -eq 0 ]]; then
      echo -e "${COLOR_YELLOW}No files changed or staged. Getting last commit files${COLOR_GRAY}"
      deploy_files=$(git diff --name-only HEAD HEAD~1)
    fi
  else
    deploy_files=$(git diff --name-only $(git merge-base $MAIN_BRANCH $CUR_BRANCH))
  fi

  # awk: get last 4 fileds from file path (DB-SCHEMA-TYPE-NAME) and sort by them
  deploy_files=$(grep ".*[sql|pkg|pks|pkb|fnc|prc|trg|vw|tps|tpb]$" <<< "$deploy_files" | awk -F "/" '{ print $0, $(NF-3), $(NF-2), $(NF-1), $NF }' | awk '{print $1}')
  echo -e "${COLOR_YELLOW}Current branch: ${COLOR_GREEN}${CUR_BRANCH}${COLOR_GRAY}"
  if [[ ${#deploy_files} -eq 0 ]]; then
    echo -e "${COLOR_RED}No files changed"
    exit 1
  fi

  for f in $deploy_files
  do
    cur_file="../$f"
    [[ -d $cur_file ]] && continue
    [[ ! -f $cur_file ]] && continue # skip removed files

    cur_schema=$(awk -F "/" '{print $(NF-2)}' <<< "$cur_file")
    cur_db=$(awk -F "/" '{print $(NF-3)}' <<< "$cur_file")

    if [[ $cur_schema != $last_schema || $cur_db != $last_db ]]; then
      text="$text\n${comment}alter session set current_schema = $cur_schema;\n"
      last_schema=$cur_schema
      last_db=$cur_db
    fi
    text="${text}${comment}@$cur_file\n"
  done

  if [[ "$1" != "show" ]]; then
    text="$text\n-- End"
    echo -e $text >> task_to_deploy.sql
  fi
  echo -e $text
}

function SqlRun() {
  CheckFile $FILE_CONFIG
  CheckFile $FILE_GLOBAL_VARS
  CheckFile $FILE_TASK
  CheckFile $FILE_BACKUP
  CheckFile $FILE_MAIN
  [[ $deploy_mode == "git_upd_run" ]] && CheckFile $FILE_GIT_UPDATE

  echo -e "${COLOR_YELLOW}Current branch: ${COLOR_GREEN}${CUR_BRANCH}${COLOR_GRAY}"
  echo -e "${COLOR_YELLOW}Deployer mode: ${COLOR_GREEN}${deploy_mode}${COLOR_GRAY}"

  tns=$(grep -iE ^'define\s*v_tns\s*=' ${FILE_CONFIG} | cut -d"=" -f2 | sed 's/^[[:space:]]*//' | tr -d \' | tr -d \")
  echo -e "${COLOR_YELLOW}TNS name: ${COLOR_GREEN}${tns}${COLOR_GRAY}"

  export NLS_LANG=AMERICAN_AMERICA.AL32UTF8

  sqlplus -l //nolog @${FILE_MAIN} $deploy_mode

  ERR_CODE=$?
  if [[ 0 != "${ERR_CODE}" ]] ; then
    echo -e "${COLOR_RED}SQL*Plus failed"
    exit 1
  fi
}

case "$1" in
-h | --help) PrintHelp ;;
-d) deploy_mode="deploy" ;;
-c) deploy_mode="compile" ;;
-i) deploy_mode="show_invalids" ;;
-b) deploy_mode="backup" ;;
--rebuild-unusable) deploy_mode="rebuild_unusable" ;;
--script-prepare) ScriptPrepare ;;
--script-show) ScriptPrepare "show";;
--git-update-prepare) deploy_mode="git_upd_gen" ;;
--git-update-run) deploy_mode="git_upd_run" ;;
--git-update) deploy_mode="git_upd" ;;
--clear-backup) rm -fv ${DIR_BACKUP}*.sql ;;
--clear-logs) rm -fv ${DIR_LOG}*.log ;;
*)
  if [[ -z "$1" ]]; then
    echo -e "${COLOR_RED}Missing argument${COLOR_GRAY}\n"
  else
    echo -e "${COLOR_RED}Invalid parameter: ${COLOR_CIAN}$1${COLOR_GRAY}\n"
  fi
   PrintHelp
   exit 1 ;;
esac

if [[ ! -z "$deploy_mode" ]]; then
  SqlRun
fi

echo -e "${COLOR_GREEN}Done :)${COLOR_GRAY}"
